import os
import requests
import sys
#from dotenv import load_dotenv
from typing import List, Dict, Any, Optional
from google.cloud import firestore
from pydantic import BaseModel
from datetime import datetime
from google import genai
import csv


# Load environment variables from a .env file (useful for local development).
# In a Cloud Run environment, secrets are typically used instead.
#load_dotenv()

# --- FIREBASE CONFIGURATION & PLACES API ---

# Firestore Initialization
# Attempts to initialize the Firestore client. It looks for a service account
# path in environment variables; otherwise, it uses the default credentials (e.g.,
# when running in a Google Cloud environment like Cloud Run).
try:
    db = firestore.Client()
    #if os.getenv("FIREBASE_CREDENTIALS_PATH"):
    #    db = firestore.Client.from_service_account_json(
    #        os.getenv("FIREBASE_CREDENTIALS_PATH")
    #    )
    #else:
        # Assumes Application Default Credentials (ADC) or other environment credentials.
    #    db = firestore.Client()
except Exception as e:
    # Logs a critical error and exits the program if Firestore initialization fails.
    print(f"ERROR: Failed to initialize Firestore: {e}", file=sys.stderr)
    sys.exit(1)

# UPDATED CONSTANTS FOR FIREBASE AND PLACES API
PLACES_API_URL = "https://places.googleapis.com/v1/places:searchText" 
API_KEY = os.getenv("GOOGLE_PLACES_API_KEY")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# URL template to get the actual public photo URL using the photo resource name.
PHOTO_API_URL = "https://places.googleapis.com/v1/{photo_name}/media?key="+API_KEY
MAX_PLACES = 20           # The maximum number of places to fetch for a given location.
MAX_RESULTS_PER_CALL = 20 # The maximum number of results the Places API returns per page.
COUNTRIES_COLLECTION_NAME = "popular_places_by_country_v1"
CITY_SUBCOLLECTION_NAME = "cities"
# A Field Mask used in the Places API request to specify which fields to return,
# optimizing the response size and cost.
FIELD_MASK = (
    "places.id,places.displayName,places.formattedAddress,places.rating,"
    "places.userRatingCount,places.types,places.location.latitude,"
    "places.location.longitude,places.photos.name"
)

# --- Pydantic DATA MODELS (Maintained for internal validation) ---

class CountryCityPair(BaseModel):
    """
    Pydantic model for a country and city pair to be processed.

    Attributes:
        country (str): The name of the country.
        city (str): The name of the city.
    """
    country: str
    city: str

class Place(BaseModel):
    """
    Pydantic model representing a single place/attraction fetched from the Places API.

    Attributes:
        place_id (str): The unique ID of the place.
        name (str): The display name of the place.
        formatted_address (str): The full address of the place.
        rating (float, optional): The user rating of the place. Defaults to None.
        user_ratings_total (int, optional): The total count of user ratings. Defaults to None.
        types (List[str]): A list of types (e.g., 'tourist_attraction', 'museum').
        latitude (float): The latitude of the place's location.
        longitude (float): The longitude of the place's location.
        photos (List[Dict[str, Any]]): The raw photo metadata from the API.
        image_url (str, optional): The public, redirect URL for the primary photo. Defaults to None.
        description (str, optional): Generated by Gemini. Defaults to None.
    """
    place_id: str
    name: str
    formatted_address: str
    rating: Optional[float] = None
    user_ratings_total: Optional[int] = None
    types: List[str]
    latitude: float
    longitude: float
    photos: List[Dict[str, Any]] # Adjusted type hint to be more specific
    image_url: Optional[str] = None
    description: Optional[str] = None

# --- LOGIC FUNCTIONS ---

def get_place_photo_url(photo_name: str) -> Optional[str]:
    """
    Gets the public redirect URL for a place photo using its resource name.
    
    The Places API returns a temporary redirect (302) to the actual image URL,
    which this function follows to retrieve the final URL.

    Args:
        photo_name (str): The resource name of the photo (e.g., 'places/...')
                          obtained from the Places API.

    Returns:
        Optional[str]: The final public URL of the image, or None if the API
                       key is missing or the request fails.
    """
    if not API_KEY:
        return None

    url = PHOTO_API_URL.format(photo_name=photo_name)
    headers = {'X-Goog-Api-Key': API_KEY}
    # Parameters to request a specific image size for the photo.
    params = {'maxWidthPx': 400} 

    try:
        # Request with allow_redirects=False to capture the 302 redirect location
        response = requests.get(url, headers=headers, params=params, allow_redirects=False)
        
        if response.status_code == 302:
            return response.headers.get('Location')
        
        # Raise an exception for bad status codes (4xx or 5xx)
        response.raise_for_status() 
        return None # Return None if status is OK but no redirect happened (unexpected for this endpoint)
    except requests.RequestException as e:
        print(f"Error fetching photo URL: {e}", file=sys.stderr)
        return None

def fetch_places(query: str, max_results: int) -> List[Dict[str, Any]]:
    """
    Fetches a list of places based on a text query using the Places API (searchText).

    It handles pagination to retrieve up to `max_results` places.

    Args:
        query (str): The search query (e.g., "popular attractions in Paris, France").
        max_results (int): The maximum number of results to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              contains the processed data for a 'Place'.

    Raises:
        ValueError: If the GOOGLE_PLACES_API_KEY environment variable is not set.
    """
    
    if not API_KEY:
        raise ValueError("GOOGLE_PLACES_API_KEY is not set.")

    all_places: List[Dict[str, Any]] = []
    page_token: Optional[str] = None
    results_fetched = 0

    headers = {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': API_KEY,
        # The Field Mask ensures we only receive necessary data, reducing latency and cost.
        'X-Goog-FieldMask': FIELD_MASK 
    }

    while results_fetched < max_results:
        
        request_body = {
            'textQuery': query,
            'pageSize': MAX_RESULTS_PER_CALL,
            'rankPreference': 'RELEVANCE' # Prioritizes more relevant results.
        }
        
        if page_token:
            # Include the token to fetch the next page of results
            request_body['pageToken'] = page_token
        
        try:
            response = requests.post(PLACES_API_URL, headers=headers, json=request_body)
            response.raise_for_status()
            data = response.json()
            
        except requests.RequestException as e:
            print(f"Error in Places API request for '{query}': {e}", file=sys.stderr)
            break
        
        current_places = data.get('places', [])
        
        # Stop if no places are returned and it's the first call (no page_token).
        if not current_places and not page_token:
            break

        for result in current_places:
            if results_fetched >= max_results:
                break
            
            image_url = None
            photos = result.get('photos', [])
            
            # Extract the URL for the first available photo
            if photos:
                photo_name = photos[0].get('name')
                if photo_name:
                    image_url = get_place_photo_url(photo_name)

            # Map the API response fields to the internal Place data structure
            place_data = {
                'place_id': result.get('id'),
                'name': result.get('displayName', {}).get('text'),
                'formatted_address': result.get('formattedAddress'),
                'rating': result.get('rating'),
                'user_ratings_total': result.get('userRatingCount'),
                'types': result.get('types', []),
                'latitude': result['location']['latitude'],
                'longitude': result['location']['longitude'],
                'photos': result.get('photos',[]),
                'image_url': image_url,
                'description': None
            }
            all_places.append(place_data)
            results_fetched += 1

        page_token = data.get('nextPageToken')
        
        # Stop if there are no more pages or the max results limit is reached.
        if not page_token or results_fetched >= max_results:
            break

    return all_places

def save_to_firestore_nested(places: List[Dict[str, Any]], country_name: str, city_name: str) -> int:
    """
    Saves a list of places to Firestore using a nested collection structure:
    `COUNTRIES_COLLECTION_NAME / [country_doc_id] / CITY_SUBCOLLECTION_NAME / [city_doc_id]`.

    Args:
        places (List[Dict[str, Any]]): The list of place data dictionaries to save.
        country_name (str): The name of the country. Used to create the top-level document ID.
        city_name (str): The name of the city. Used to create the nested document ID.

    Returns:
        int: The number of places successfully saved.

    Raises:
        ConnectionError: If the Firestore client is not initialized.
    """

    global db
    if db is None:
        raise ConnectionError("Firestore is not initialized.")

    # Create standardized document IDs (lowercase, spaces replaced by underscores)
    country_doc_id = country_name.lower().replace(" ", "_")
    city_doc_id = city_name.lower().replace(" ", "_")
    
    # Define the document reference path
    doc_ref = (
        db.collection(COUNTRIES_COLLECTION_NAME)
        .document(country_doc_id)
        .collection(CITY_SUBCOLLECTION_NAME)
        .document(city_doc_id)
    )
    
    # Convert the list of places into a map where the key is the place_id for easier retrieval/lookup in Firestore
    places_dict = {
        place['place_id']: place
        for place in places
    }
    
    data_to_save = {
        "country_name": country_name,
        "city_name": city_name,
        "total_places": len(places),
        "places": places_dict,
        # Use SERVER_TIMESTAMP to record the exact time of the last update
        "updated_at": firestore.SERVER_TIMESTAMP 
    }

    doc_ref.set(data_to_save)
    return len(places)


def generate_place_description(place_name: str, city: str, country: str) -> Optional[str]:
    """
    Generate a concise description of a place using the Gemini API.

    The description is limited to 140 characters.

    Args:
        place_name (str): Name of the place
        city (str): City if the place
        country (str): Country of the place

    Returns:
        Optional[str]: The generated description, truncated to 140 characters, or None if it fails.
    """
    
    if not GEMINI_API_KEY:
        return None

    # Prompt
    prompt = (
        f"Generate an attractive and concise tourist description for '{place_name}' "
        f"located in {city}, {country}. The description should be maximum 140 characters "
        "Be brief and captivating!"
    )

    print(prompt)

    try:
      
        client = genai.Client()

        response = client.models.generate_content(
            model="gemini-2.5-flash", contents=prompt
        )

     
        description = response.text
   
        return description


    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return None


def load_locations_from_csv(file_path: str) -> List[CountryCityPair]:
    """
    Read Country/City pairs from a specific CSV file.

    Args:
        file_path (str): Path of file

    Returns:
        List[CountryCityPair]: Object List
    """
    locations: List[CountryCityPair] = []
    try:
        with open(file_path, mode='r', newline='', encoding='utf-8') as file:
            # Asume que el encabezado es 'country,city'
            reader = csv.DictReader(file)
            for row in reader:
                # Normalizar los nombres antes de crear el modelo
                country = row.get('country', '').strip().upper()
                city = row.get('city', '').strip().upper()
                if country and city:
                    locations.append(CountryCityPair(country=country, city=city))
        print(f"INFO: Successfully loaded {len(locations)} locations from {file_path}.")
        return locations
    except FileNotFoundError:
        print(f"ERROR: CSV file not found at {file_path}.", file=sys.stderr)
        return []
    except Exception as e:
        print(f"ERROR: Failed to read CSV {file_path}: {e}", file=sys.stderr)
        return []

# --- MAIN FUNCTION FOR CLOUD RUN JOB ---

def main_job_handler():
    """
    Main entry point for the batch processing job, typically run via Cloud Run Jobs.

    This function defines a list of locations, iterates through them, fetches
    popular places using the Google Places API, and saves the results to Firestore.
    It logs the progress and provides a final summary.
    """
    print(f"START batch processing job: {datetime.now()}")

    # 1. Define the list of locations to be processed.
    # The list is hardcoded for simplicity and cost control. In a production
    # environment, this list could be dynamically loaded (e.g., from a CSV or a database).

    task_index = int(os.getenv("CLOUD_RUN_TASK_INDEX", 0))
    csv_file_name = f"locations_part_{task_index + 1}.csv"

    print(f"--- Cloud Run Task Configuration ---")
    print(f"Task Index: {task_index}")
    print(f"Processing CSV: {csv_file_name}")
    print(f"------------------------------------")

    try:
        locations_to_process = load_locations_from_csv(csv_file_name)
    except Exception as e:
        print(f"CRITICAL ERROR: Could not load data for task index {task_index}. {e}", file=sys.stderr)
        # Terminar el job de forma an√≥mala si no se pueden cargar los datos
        sys.exit(1)

    #locations_to_process: List[CountryCityPair] = [
        #CountryCityPair(country="ARGENTINA", city="BUENOS AIRES"),
        #CountryCityPair(country="BRAZIL", city="SAO PAULO"),
        # CountryCityPair(country="BRAZIL", city="CURITIBA"),
        # CountryCityPair(country="CHINA", city="HONG KONG"),
        # CountryCityPair(country="PERU", city="AREQUIPA"),
        # CountryCityPair(country="PERU", city="LIMA"),
        # CountryCityPair(country="SPAIN", city="MADRID"),
        # CountryCityPair(country="SPAIN", city="BARCELONA"),
        # CountryCityPair(country="UNITED STATES", city="NEW YORK"),
    #]

    total_requested = len(locations_to_process)
    successful_stores = 0

    if total_requested == 0:
        print("WARNING: No locations to process in this task. Exiting.")
        return
    
    # 2. Iterate over the locations and call the save logic
    for i, location in enumerate(locations_to_process):
        country = location.country
        city = location.city
        log_prefix = f"[{i+1}/{total_requested}] Processing {city}, {country}: "
        
        print(f"{log_prefix} Starting search...")

        try:
            # Construct a targeted query to find popular tourist spots
            query = f"popular attractions and landmarks in {city}, {country}"
            places_data = fetch_places(query, MAX_PLACES)

            if places_data:

                print(f"{log_prefix} Generating Gemini descriptions...")
                for place in places_data:
                    place_name = place.get('name', 'Unknown Place')
                    description = generate_place_description(place_name, city, country)
                    print(description)
                    place['description'] = description

                saved_count = save_to_firestore_nested(places_data, country, city)
                successful_stores += 1
                print(f"{log_prefix} SUCCESS. {saved_count} places saved.")
            else:
                print(f"{log_prefix} WARNING. No locations were found or there was an API error.")

        except Exception as e:
            # Log the error but continue to the next location to complete the batch job
            print(f"{log_prefix} CRITICAL ERROR. Processing failure: {e.__class__.__name__} - {str(e)}", file=sys.stderr)
    
    
    print("--- SUMMARY OF THE WORK ---")
    print(f"Total number of locations requested: {total_requested}")
    print(f"Successful storage in Firestore: {successful_stores}")
    

    if successful_stores < total_requested:
        # Log a non-zero exit message but still mark the job as "completed" for the orchestration system
        print("COMPLETED. There were errors, but the job is marked as completed.")
        
    print(f"END of batch processing job: {datetime.now()}")


# --- START POINT ---
if __name__ == "__main__":


    # Essential check for the API key before starting the job.
    if not API_KEY:
        print("ERROR: The environment variable GOOGLE_PLACES_API_KEY is not set.", file=sys.stderr)
        sys.exit(1)
        
    main_job_handler()